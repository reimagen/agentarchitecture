"""Workflow CRUD REST API endpoints."""
import os
import uuid
import sys
from pathlib import Path
from typing import Optional

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel
from dotenv import load_dotenv

from agent.workflow_analyzer_agent.orchestrator import WorkflowAnalyzerOrchestrator
from database.exceptions import WorkflowNotFoundError, FirestoreError
from database.firebase_client import FirebaseClient
from database.workflow_repository import WorkflowRepository


class WorkflowRequest(BaseModel):
    """Request body for workflow analysis."""
    workflow_text: str
    workflow_id: Optional[str] = None
    workflow_name: Optional[str] = None


class WorkflowNameUpdate(BaseModel):
    """Request body for updating workflow name."""
    workflow_name: str

router = APIRouter(prefix="/workflows", tags=["workflows"])

# Global orchestrator and repository instances
_orchestrator = None
_repository = None


def get_orchestrator():
    """Get or initialize orchestrator."""
    global _orchestrator
    if _orchestrator is None:
        _repository_instance = WorkflowRepository()
        _orchestrator = WorkflowAnalyzerOrchestrator(workflow_repository=_repository_instance)
    return _orchestrator


def get_repository():
    """Get or initialize repository."""
    global _repository
    if _repository is None:
        # Ensure Firebase is initialized
        try:
            FirebaseClient.get_db()
        except RuntimeError:
            # Firebase not initialized yet, initialize it
            backend_dir = Path(__file__).parent.parent.resolve()
            default_creds_path = backend_dir / "firebase-service-account.json"
            firebase_creds_path = os.getenv("FIREBASE_CREDENTIALS_PATH", default_creds_path)
            FirebaseClient.initialize(firebase_creds_path)

        _repository = WorkflowRepository()
    return _repository


@router.post("", status_code=201)
async def create_workflow(request: WorkflowRequest):
    """
    Submit a workflow for analysis.

    Request body:
    {
        "workflow_text": "customer support workflow...",
        "workflow_id": "optional_uuid_or_null"
    }

    Returns:
    {
        "workflow_id": "wf_a1b2c3d4",
        "approvalStatus": "PENDING",
        "createdAt": "2025-11-18T20:10:00.000Z",
        "updatedAt": "2025-11-18T20:10:00.000Z",
        "analysis": { /* WorkflowAnalysis JSON */ }
    }
    """
    try:
        workflow_text = request.workflow_text
        workflow_name = request.workflow_name # Retrieve workflow_name
        if not workflow_text:
            raise HTTPException(status_code=400, detail="workflow_text is required")

        # Initialize Firebase and repository FIRST (needed for orchestrator)
        repository = get_repository()

        # Run analysis (orchestrator generates workflow_id from session_id)
        orchestrator = get_orchestrator()
        analysis = await orchestrator.analyze_workflow(workflow_text, workflow_name=workflow_name) # Pass workflow_name


        # Use the workflow_id generated by the orchestrator
        workflow_id = analysis.workflow_id

        # Retrieve from Firestore (should already be saved by orchestrator auto-save)
        workflow_doc = repository.get_workflow_full(workflow_id)

        if not workflow_doc:
            raise HTTPException(status_code=500, detail="Failed to retrieve saved workflow")

        return {
            "workflow_id": workflow_id,
            "approvalStatus": workflow_doc.get("approvalStatus"),
            "createdAt": workflow_doc.get("createdAt"),
            "updatedAt": workflow_doc.get("updatedAt"),
            "analysis": workflow_doc.get("analysis"),
            "workflowName": workflow_doc.get("workflowName"),
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to analyze workflow: {str(e)}")


@router.get("/{workflow_id}")
async def get_workflow(workflow_id: str):
    """
    Retrieve a workflow by ID.

    Returns:
    {
        "workflow_id": "wf_a1b2c3d4",
        "originalText": "customer support workflow...",
        "analysis": { /* WorkflowAnalysis JSON */ },
        "orgChart": { /* AgentOrgChart JSON or null */ },
        "approvalStatus": "PENDING|APPROVED|REJECTED",
        "approvedBy": "user_id or null",
        "approvedAt": "timestamp or null",
        "createdAt": "2025-11-18T20:10:00.000Z",
        "updatedAt": "2025-11-18T20:10:00.000Z",
        "metadata": { /* custom fields */ }
    }
    """
    try:
        repository = get_repository()
        workflow_doc = repository.get_workflow_full(workflow_id)

        if not workflow_doc:
            raise HTTPException(status_code=404, detail=f"Workflow {workflow_id} not found")

        return {
            "workflow_id": workflow_id,
            "originalText": workflow_doc.get("originalText"),
            "analysis": workflow_doc.get("analysis"),
            "orgChart": workflow_doc.get("orgChart"),
            "agentRegistry": workflow_doc.get("agentRegistry"),
            "toolRegistry": workflow_doc.get("toolRegistry"),
            "approvalStatus": workflow_doc.get("approvalStatus"),
            "approvedBy": workflow_doc.get("approvedBy"),
            "approvedAt": workflow_doc.get("approvedAt"),
            "createdAt": workflow_doc.get("createdAt"),
            "updatedAt": workflow_doc.get("updatedAt"),
            "metadata": workflow_doc.get("metadata"),
            "workflowName": workflow_doc.get("workflowName"),
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve workflow: {str(e)}")


@router.get("")
async def list_workflows(
    status: Optional[str] = Query(None, regex="^(PENDING|APPROVED|REJECTED)$"),
    limit: int = Query(20, ge=10, le=100),
):
    """
    List workflows with optional filtering.

    Query parameters:
    - status: Filter by approval status (PENDING|APPROVED|REJECTED)
    - limit: Number of results to return (10-100, default 20)

    Returns:
    {
        "workflows": [
            {
                "workflow_id": "wf_a1b2c3d4",
                "approvalStatus": "PENDING",
                "createdAt": "2025-11-18T20:10:00.000Z",
                "updatedAt": "2025-11-18T20:10:00.000Z"
            },
            ...
        ]
    }
    """
    try:
        repository = get_repository()
        workflows = repository.list_workflows(approval_status=status, limit=limit)

        return {"workflows": workflows}

    except Exception as e:
        error_detail = f"Failed to list workflows. Internal error: {str(e)}"
        print(f"ERROR: {error_detail}")  # Log the full error to the console
        raise HTTPException(status_code=500, detail=error_detail)


@router.patch("/{workflow_id}/name")
async def update_workflow_name(workflow_id: str, request: WorkflowNameUpdate):
    """Update the workflow's display name."""
    try:
        new_name = (request.workflow_name or "").strip()
        if not new_name:
            raise HTTPException(status_code=400, detail="workflow_name must be a non-empty string")

        repository = get_repository()
        updated_doc = repository.update_workflow_name(workflow_id, new_name)

        return {
            "workflow_id": workflow_id,
            "workflowName": updated_doc.get("workflowName"),
            "updatedAt": updated_doc.get("updatedAt"),
        }

    except WorkflowNotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except HTTPException:
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to update workflow name: {str(e)}")


@router.delete("/{workflow_id}")
async def delete_workflow(workflow_id: str, hard_delete: bool = False):
    """
    Delete a workflow (soft or hard delete).

    Query parameters:
    - hard_delete: If true, permanently delete. If false (default), soft delete.

    Returns:
    {
        "message": "Workflow deleted successfully",
        "workflow_id": "wf_a1b2c3d4"
    }
    """
    try:
        repository = get_repository()
        success = repository.delete_workflow(workflow_id, soft_delete=not hard_delete)

        if not success:
            raise HTTPException(status_code=500, detail="Failed to delete workflow")

        return {
            "message": "Workflow deleted successfully",
            "workflow_id": workflow_id,
        }

    except WorkflowNotFoundError:
        raise HTTPException(status_code=404, detail=f"Workflow {workflow_id} not found")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to delete workflow: {str(e)}")
