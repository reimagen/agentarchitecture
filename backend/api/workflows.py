"""Workflow CRUD REST API endpoints."""
import os
import uuid
import sys
from pathlib import Path
from typing import Optional

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel
from dotenv import load_dotenv

# Load environment variables from backend/.env
env_file = Path(__file__).parent.parent / ".env"
load_dotenv(env_file)

# Add backend to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from agent.workflow_analyzer_agent.orchestrator import WorkflowAnalyzerOrchestrator
from database.exceptions import WorkflowNotFoundError, FirestoreError
from database.firebase_client import FirebaseClient
from database.workflow_repository import WorkflowRepository


class WorkflowRequest(BaseModel):
    """Request body for workflow analysis."""
    workflow_text: str
    workflow_id: Optional[str] = None

router = APIRouter(prefix="/workflows", tags=["workflows"])

# Global orchestrator and repository instances
_orchestrator = None
_repository = None


def get_orchestrator():
    """Get or initialize orchestrator."""
    global _orchestrator
    if _orchestrator is None:
        _repository_instance = WorkflowRepository()
        _orchestrator = WorkflowAnalyzerOrchestrator(workflow_repository=_repository_instance)
    return _orchestrator


def get_repository():
    """Get or initialize repository."""
    global _repository
    if _repository is None:
        # Ensure Firebase is initialized
        try:
            FirebaseClient.get_db()
        except RuntimeError:
            # Firebase not initialized yet, initialize it
            firebase_creds_path = os.getenv("FIREBASE_CREDENTIALS_PATH", "./firebase-service-account.json")
            FirebaseClient.initialize(firebase_creds_path)

        _repository = WorkflowRepository()
    return _repository


@router.post("", status_code=201)
async def create_workflow(request: WorkflowRequest):
    """
    Submit a workflow for analysis.

    Request body:
    {
        "workflow_text": "customer support workflow...",
        "workflow_id": "optional_uuid_or_null"
    }

    Returns:
    {
        "workflow_id": "wf_a1b2c3d4",
        "approvalStatus": "PENDING",
        "createdAt": "2025-11-18T20:10:00.000Z",
        "updatedAt": "2025-11-18T20:10:00.000Z",
        "analysis": { /* WorkflowAnalysis JSON */ }
    }
    """
    try:
        workflow_text = request.workflow_text
        if not workflow_text:
            raise HTTPException(status_code=400, detail="workflow_text is required")

        # Initialize Firebase and repository FIRST (needed for orchestrator)
        repository = get_repository()

        # Run analysis (orchestrator generates workflow_id from session_id)
        orchestrator = get_orchestrator()
        analysis = await orchestrator.analyze_workflow(workflow_text)

        # Use the workflow_id generated by the orchestrator
        workflow_id = analysis.workflow_id

        # Retrieve from Firestore (should already be saved by orchestrator auto-save)
        workflow_doc = repository.get_workflow_full(workflow_id)

        if not workflow_doc:
            raise HTTPException(status_code=500, detail="Failed to retrieve saved workflow")

        return {
            "workflow_id": workflow_id,
            "approvalStatus": workflow_doc.get("approvalStatus"),
            "createdAt": workflow_doc.get("createdAt"),
            "updatedAt": workflow_doc.get("updatedAt"),
            "analysis": workflow_doc.get("analysis"),
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to analyze workflow: {str(e)}")


@router.get("/{workflow_id}")
async def get_workflow(workflow_id: str):
    """
    Retrieve a workflow by ID.

    Returns:
    {
        "workflow_id": "wf_a1b2c3d4",
        "originalText": "customer support workflow...",
        "analysis": { /* WorkflowAnalysis JSON */ },
        "orgChart": { /* AgentOrgChart JSON or null */ },
        "approvalStatus": "PENDING|APPROVED|REJECTED",
        "approvedBy": "user_id or null",
        "approvedAt": "timestamp or null",
        "createdAt": "2025-11-18T20:10:00.000Z",
        "updatedAt": "2025-11-18T20:10:00.000Z",
        "metadata": { /* custom fields */ }
    }
    """
    try:
        repository = get_repository()
        workflow_doc = repository.get_workflow_full(workflow_id)

        if not workflow_doc:
            raise HTTPException(status_code=404, detail=f"Workflow {workflow_id} not found")

        return {
            "workflow_id": workflow_id,
            "originalText": workflow_doc.get("originalText"),
            "analysis": workflow_doc.get("analysis"),
            "orgChart": workflow_doc.get("orgChart"),
            "agentRegistry": workflow_doc.get("agentRegistry"),
            "toolRegistry": workflow_doc.get("toolRegistry"),
            "approvalStatus": workflow_doc.get("approvalStatus"),
            "approvedBy": workflow_doc.get("approvedBy"),
            "approvedAt": workflow_doc.get("approvedAt"),
            "createdAt": workflow_doc.get("createdAt"),
            "updatedAt": workflow_doc.get("updatedAt"),
            "metadata": workflow_doc.get("metadata"),
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve workflow: {str(e)}")


@router.get("")
async def list_workflows(
    status: Optional[str] = Query(None, regex="^(PENDING|APPROVED|REJECTED)$"),
    limit: int = Query(20, ge=10, le=100),
):
    """
    List workflows with optional filtering.

    Query parameters:
    - status: Filter by approval status (PENDING|APPROVED|REJECTED)
    - limit: Number of results to return (10-100, default 20)

    Returns:
    {
        "workflows": [
            {
                "workflow_id": "wf_a1b2c3d4",
                "approvalStatus": "PENDING",
                "createdAt": "2025-11-18T20:10:00.000Z",
                "updatedAt": "2025-11-18T20:10:00.000Z"
            },
            ...
        ]
    }
    """
    try:
        repository = get_repository()
        workflows = repository.list_workflows(approval_status=status, limit=limit)

        return {"workflows": workflows}

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to list workflows: {str(e)}")


@router.delete("/{workflow_id}")
async def delete_workflow(workflow_id: str, hard_delete: bool = False):
    """
    Delete a workflow (soft or hard delete).

    Query parameters:
    - hard_delete: If true, permanently delete. If false (default), soft delete.

    Returns:
    {
        "message": "Workflow deleted successfully",
        "workflow_id": "wf_a1b2c3d4"
    }
    """
    try:
        repository = get_repository()
        success = repository.delete_workflow(workflow_id, soft_delete=not hard_delete)

        if not success:
            raise HTTPException(status_code=500, detail="Failed to delete workflow")

        return {
            "message": "Workflow deleted successfully",
            "workflow_id": workflow_id,
        }

    except WorkflowNotFoundError:
        raise HTTPException(status_code=404, detail=f"Workflow {workflow_id} not found")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to delete workflow: {str(e)}")
